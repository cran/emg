18/1000
1.018
log(1.018)
exp(0.02)
?write.csv
library(GEOquery)
source("http://bioconductor.org/biocLite.R")#
biocLite("limma")#
biocLite("affy")#
biocLite("PartheenMetaData.db")#
biocLite("GEOquery")#
library(GEOquery)
gse <- getGEO("GSE16179", GSEMatrix=TRUE)
library(GEOquery)
biocLite("limma")#
biocLite("affy")#
biocLite("PartheenMetaData.db")#
biocLite("GEOquery")
library(GEOquery)
library(limma)
gse2 <- getGEO("GSE18328", GSEMatrix=TRUE)
p <- phenoData(gse2[[1]])
colnames(p)
names(p)
str(p)
f <- featureData(gse2[[2]])
f <- featureData(gse2[[1]])
str(f)
f[1,]
f[,2]
f$Column
f@dimLabels
f[1,]
f[1,1]
f[2,1]
f[3,1]
f[1,2]
f[1,3]
f[1,4]
f[1,5]
f[1,6]
featureData(gse2[[1]])
f[1]
f[2]
f[3]
e <- exprs(gse2)
hist(f[,1])
eset <- GDS2eSet(gse2[[1]])
g <- gse2[[1]]
hist(g[1,])
gg <- GSMList(g)
class(g)
str(g)
e <- exprs(g)
hist(e[1,])
hist(e[1,], breaks=10)
hist(e[2,], breaks=10)
hist(e[3,], breaks=10)
hist(e[4,], breaks=10)
hist(e[5,], breaks=10)
hist(e[6,], breaks=10)
?topTable
4471.16 - 125
4471.16 - 125-4.75
4471.16 - 125-4.75-854
4471.16 - 125-4.75-854-172
4471.16 - 125-4.75-854-172-180
4471.16 - 125-4.75-854-172-180-1323.81
library(emg)#
library(lattice)#
#
##########################################################
# Generation (division) rate estimate based on EMG model#
# #
# Eq. 10 in Powell (1956) J Gen Microbiol 15:492-511#
# modified to EMG parameters of IMT distributions#
##########################################################
#
generation.rate <- function(mu, sigma, lambda)#
{#
  g <- function(t, v)  {exp(-v * t) * demg(t, mu, sigma, lambda) }#
  f <- function(v) {integrate(g, 0, Inf, v)$value - 0.5}#
       # May need to adjust max value of integration range from Inf to 100#
  v <- uniroot(f, lower=1e-6, upper=1)$root#
  names(v) <- "p"#
  v#
}#
#
########################################################
##
mean.emg <- function(mu, sigma, lambda)#
{#
  mu + 1/lambda#
}#
#
est.err <- function(mu, sigma, lambda)#
{#
  r <- log(2)/generation.rate(mu, sigma, lambda) - mean.emg(mu, sigma, lambda)#
  names(r) <- "err"#
  r#
}
mean.emg(20, 1, 1)
est.err(20, 1, 1)
generation.rate(20, 1, 1)
generation.rate(20, 2, 2)
generation.rate(20, 3, 3)
generation.rate(20, 3, 4)
generation.rate(20, 4, 4)
generation.rate(20, 4, 1.2)
generation.rate(20, 4, 0.5)
generation.rate(20, 1, 0.5)
est.err(20 ,1,0.5)
est.err(20 ,1,2)
est.err(20 ,2,2)
1/15
?contour
?seq
l <- seq(1/15, 0.5, length.out=100)
l
n <- 100#
mu <- 20#
l <- seq(1/15, 0.5, length.out=n)#
s <- seq(1, 8, length.out=n)
?apply
?contour
?outer
outer(l,s)
outer(s, l, )
?outer
outer(s, l, )
z <- outer(s, l, FUN=function(x, y){est.err(mu, x, y)})
#
generation.rate <- function(mu, sigma, lambda)#
{#
  r <- rep(0, length(mu))#
  #
  for(i in 1:length(mu))#
  {#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu, sigma, lambda) }#
    f <- function(v) {integrate(g, 0, Inf, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-6, upper=1)$root#
    names(v) <- "p"#
    r[i] <- v#
  }#
  r#
}
generation.rate <- function(mu, sigma, lambda)#
{#
  r <- rep(0, length(mu))#
  #
  for(i in 1:length(mu))#
  {#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu[i], sigma[i], lambda[i]) }#
    f <- function(v) {integrate(g, 0, Inf, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-6, upper=1)$root#
    names(v) <- "p"#
    r[i] <- v#
  }#
  r#
}
generation.rate(c(20, 20), c(1,1), c(0.3, 0.2))
generation.rate(c(20, 20), c(1,1), c(0.3))
z <- outer(s, l, FUN=function(x, y){est.err(mu, x, y)})
z
contour(s, l, z)
 contour(s, l, z, xlab="Sigma", ylab="Lambda", main='estimation error for mu=20')
k <- seq(2, 15, length.out=n)#
z <- outer(s, k, FUN=function(x, y){est.err(mu, x, 1/y)})#
contour(s, l, z, xlab="Sigma", ylab="Kappa", main='estimation error for mu=20')
k <- seq(2, 15, length.out=n)#
z <- outer(s, k, FUN=function(x, y){est.err(mu, x, 1/y)})#
contour(s, k, z, xlab="Sigma", ylab="Kappa", main='estimation error for mu=20')
n <- 100#
mu <- 20#
l <- seq(1/15, 1/2, length.out=n)#
s <- seq(1, 8, length.out=n)#
#
z <- outer(s, l, FUN=function(x, y){est.err(mu, x, y)})#
#
contour(s, l, z, xlab="Sigma", ylab="Lambda", main='estimation error for mu=20')\
n <- 100#
mu <- 20#
l <- seq(1/15, 1/2, length.out=n)#
s <- seq(1, 8, length.out=n)#
#
z <- outer(s, l, FUN=function(x, y){est.err(mu, x, y)})#
#
contour(s, l, z, xlab="Sigma", ylab="Lambda", main='estimation error for mu=20')
k <- seq(2, 15, length.out=n)#
z <- outer(s, k, FUN=function(x, y){est.err(mu, x, 1/y)})#
contour(s, k, z, xlab="Sigma", ylab="Kappa", main='estimation error for mu=20')
z
l
s
est.err(mu, 8, 0.5)
z[100:100]
l[100]
s[100]
s[1]
l[1]
est.err(mu, s[1], l[1])
z[1]
z[1:1]
z[1,1]
z <- outer(s, l, FUN=function(x, y){est.err(mu, x, y)})
z[1,1]
est.err(mu, s[100], l[100])
z[100,100]
est.err(mu, l[100], s[100])
x <- NULL
y <- NULL
z <- outer(s, l, FUN=function(x, y){est.err(mu, x, y)})
z
z <- outer(s, l, FUN=function(x){est.err(mu, x[1], x[2])})
?outer
f <- function(s, l){est.err(mu, s, l)}#
z <- outer(s, l, FUN=f)
z
mean.emg <- function(mu, sigma, lambda)#
{#
  print(mu)#
  mu + 1/lambda#
}
mean.emg(c(1,1), c())
generation.rate <- function(mu, sigma, lambda)#
{#
  r <- rep(0, length(sigma))#
  #
  for(i in 1:length(sigma))#
  {#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu[i], sigma[i], lambda[i]) }#
    f <- function(v) {integrate(g, 0, Inf, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-6, upper=1)$root#
    names(v) <- "p"#
    r[i] <- v#
  }#
  r#
}
z <- outer(s, l, FUN=f)
generation.rate <- function(mu, sigma, lambda)#
{#
#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu[i], sigma[i], lambda[i]) }#
    f <- function(v) {integrate(g, 0, Inf, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-6, upper=1)$root#
    names(v) <- "p"#
    v#
}
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    z[i,j] <- est.err(mu, s[i], l[j])#
  }#
}
##########################################################
#
generation.rate <- function(mu, sigma, lambda)#
{#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu[i], sigma[i], lambda[i]) }#
    f <- function(v) {integrate(g, 0, Inf, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-6, upper=1)$root#
    names(v) <- "p"#
    v#
}#
#
########################################################
##
mean.emg <- function(mu, sigma, lambda)#
{#
  mu + 1/lambda#
}#
#
est.err <- function(mu, sigma, lambda)#
{#
  r <- log(2)/generation.rate(mu, sigma, lambda) - mean.emg(mu, sigma, lambda)#
  names(r) <- "err"#
  r#
}
s <- seq(1, 8, length.out=n)#
l <- seq(1/15, 1/2, length.out=n)
z <- matrix(rep(0, n*n), nrow=n)
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    z[i,j] <- est.err(mu, s[i], l[j])#
  }#
}
z
z <- matrix(rep(NA, n*n), nrow=n)#
#
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    print(paste(i,j))#
    z[i,j] <- est.err(mu, s[i], l[j])#
  }#
}
s[2]
l[1]
generation.rate(mu, 1.07, 0.06)
generation.rate <- function(mu, sigma, lambda)#
{#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu, sigma, lambda) }#
    f <- function(v) {integrate(g, 0, Inf, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-6, upper=1)$root#
    names(v) <- "p"#
    v#
}
z <- matrix(rep(NA, n*n), nrow=n)#
#
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    print(paste(i,j))#
    z[i,j] <- est.err(mu, s[i], l[j])#
  }#
}
s[21]
l[80]
generation.rate(20, 2.4, 0.412)
generation.rate(20, s[21], l[80])
generation.rate <- function(mu, sigma, lambda)#
{#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu, sigma, lambda) }#
    f <- function(v) {integrate(g, 0, 200, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-6, upper=1)$root#
    names(v) <- "p"#
    v#
}
generation.rate(20, s[21], l[80])
generation.rate <- function(mu, sigma, lambda)#
{#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu, sigma, lambda) }#
    f <- function(v) {integrate(g, 0, 1000, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-6, upper=1)$root#
    names(v) <- "p"#
    v#
}
generation.rate(20, s[21], l[80])
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    z[i,j] <- est.err(mu, s[i], l[j])#
  }#
}
contour(s, l, z, xlab="Sigma", ylab="Lambda", main='estimation error for mu=20')
k <- seq(2, 15, length.out=n)#
z2 <- matrix(rep(NA, n*n), nrow=n)#
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    z2[i,j] <- est.err(mu, s[i], 1/k[j])#
  }#
}#
#
contour(s, k, z2, xlab="Sigma", ylab="Kappa", main='estimation error for mu=20')
n <- 200#
mu <- 20#
#
s <- seq(1, 8, length.out=n)#
l <- seq(1/15, 1/2, length.out=n)#
z <- matrix(rep(NA, n*n), nrow=n)#
#
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    z[i,j] <- est.err(mu, s[i], l[j])#
  }#
}#
#
#
contour(s, l, z, xlab="Sigma", ylab="Lambda", main='estimation error for mu=20')
s <- seq(1, 8, length.out=n)#
l <- seq(1/15, 1/2, length.out=n)#
z <- matrix(rep(NA, n*n), nrow=n)#
#
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    print(paste(i,j))#
    z[i,j] <- est.err(mu, s[i], l[j])#
  }#
}
est.err(mu, s[5], l[133])
s[5]
l[133]
mu <- 20
sigma <- s[5]
lambda <- l[133]
    g <- function(t, v)  {exp(-v * t) * demg(t, mu, sigma, lambda) }#
    f <- function(v) {integrate(g, 0, 1000, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100
    v <- uniroot(f, lower=1e-6, upper=1)$root
v
?uniroot
    g <- function(t, v)  {exp(-v * t) * demg(t, mu, sigma, lambda) }#
    f <- function(v) {print(v); integrate(g, 0, 1000, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100
?uniroot
 v <- uniroot(f, lower=1e-6, upper=1)$root
f(1e-06)
f(1)
f(1e-05)
x<-seq(1e-06, 1, 100)
x
x<-seq(1e-06, 1, length.out=100)
x
plot(x, f(x))
y <- apply(x, FUN=y)
y <- sapply(x, FUN=y)
y <- sapply(x, FUN=f)
x
t
y
plot(x, y)
lambda
sigma
plot(x, y, typ='l')
1e-3
generation.rate <- function(mu, sigma, lambda)#
{#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu, sigma, lambda) }#
    f <- function(v) {integrate(g, 0, 1000, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-4, upper=1)$root#
    names(v) <- "p"#
    v#
}
est.err(mu, s[5], l[133])
y <- sapply(x, FUN=f)
plot(x, y, typ='l')
generation.rate <- function(mu, sigma, lambda)#
{#
    g <- function(t, v)  {exp(-v * t) * demg(t, mu, sigma, lambda) }#
    f <- function(v) {integrate(g, 0, 1000, v)$value - 0.5}#
         # May need to adjust max value of integration range from Inf to 100#
    v <- uniroot(f, lower=1e-4, upper=1)$root#
    names(v) <- "p"#
    v#
}
n <- 10#
mu <- 20#
#
s <- seq(1, 8, length.out=n)#
l <- seq(1/15, 1/2, length.out=n)#
z <- matrix(rep(NA, n*n), nrow=n)#
#
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    print(paste(i,j))#
    z[i,j] <- est.err(mu, s[i], l[j])#
  }#
}#
#
#
contour(s, l, z, xlab="Sigma", ylab="Lambda", main='estimation error for mu=20')
k <- seq(2, 15, length.out=n)#
z2 <- matrix(rep(NA, n*n), nrow=n)#
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    z2[i,j] <- est.err(mu, s[i], 1/k[j])#
  }#
}#
#
contour(s, k, z2, xlab="Sigma", ylab="Kappa", main='estimation error for mu=20')
percent.err <- function(mu, sigma, lambda)#
{#
  r <- log(2)/generation.rate(mu, sigma, lambda)#
  names(r) <- "err"#
  (r - mean.emg(mu, sigma, lambda))/r#
}
percent.err <- function(mu, sigma, lambda)#
{#
  r <- log(2)/generation.rate(mu, sigma, lambda)#
  names(r) <- "err"#
  (mean.emg(mu, sigma, lambda)-r)/r#
}
percent <- matrix(rep(NA, n*n), nrow=n)#
for(i in 1:n)#
{#
  for(j in 1:n)#
  {#
    percent[i,j] <- percent.err(mu, s[i], 1/k[j])#
  }#
}#
#
contour(s, k, percent, xlab="Sigma", ylab="Kappa", main='estimation error percent', sub="mu=20")
?pnorm
demg <- function(x, mu=0, sigma=1, lambda=1, log=FALSE)#
{#
  l <- max(length(x), length(mu), length(sigma), length(lambda))#
  #
  x     <- rep(x,     times=ceiling(l/length(x)),     length.out=l)#
  mu    <- rep(mu,    times=ceiling(l/length(mu)),    length.out=l)#
  sigma <- rep(sigma, times=ceiling(l/length(sigma)), length.out=l)#
  lambda<- rep(lambda,times=ceiling(l/length(lambda)),length.out=l)#
  #
  if(min(sigma) <= 0.0)       {stop("Sigma must be greater than zero") }#
  if(min(lambda) <= 0.0)      {stop("Lambda must be greater than zero")}#
#
  erfc <- pnorm((mu+lambda*sigma*sigma-x)/ sigma , lower.tail = FALSE, log.p=log)#
  #
  if(log)#
  {#
    result <- lambda/2 * (2*mu+lambda*sigma*sigma-2*x) + Re(erfc) + log(lambda)#
  } else {#
    result <- exp(lambda/2 * (2*mu+lambda*sigma*sigma-2*x)) * Re(erfc) * lambda#
  }#
  #
  # Too small to compute, zero it#
  result[is.nan(result)] <- 0#
#
  result#
}
demg(20, 20, 1, 1)
demg(20, 20, 1, 1, log=TRUE)
log(demg(20, 20, 1, 1))
emg.nllik <- function(x, mu, sigma, lambda)#
{#
  #print(paste('nllemg',length(x), mu, sigma, lambda, '=>', demg(x, mu, sigma, lambda)))#
  -sum(demg(x, mu, sigma, lambda, log=TRUE))#
}
pnorm(0.5)
pnorm(0.5, log.p=TRUE)
log(pnorm(0.5))
pnorm(0.5, lower.tail)
pnorm(0.5, lower.tail=TRUE)
pnorm(0.5, lower.tail=FALSE)
pnorm(0.5, lower.tail=FALSE, log.p=TRUE)
log(pnorm(0.5, lower.tail=FALSE))
qnorm(0.025)
qnorm(1-0.025, lower.tail=FALES)
qnorm(1-0.025, lower.tail=FALSE)
qnorm(1-0.025, 22, lower.tail=FALSE)
qnorm(0.025, 22)
pnorm(1)
pnorm(1, lower.tail=FALSE)
data(pc9_3um_erlotinib)
library(emg)
data(pc9_3um_erlotinib)
divisions <- subset(pc9_3um_erlotinib, end.of.movie='N' & died='N')
divisions <- subset(pc9_3um_erlotinib, end.of.movie=='N' & died=='N')
divisions
divisions <- subset(pc9_3um_erlotinib, end.of.movie=='N' & died=='N')$observed
divisions
hist(division)
hist(divisions)
pc9_3um_erlotinib
orig <- read.csv("~/20110909WellF08_Tracking.csv")
orig <- read.csv("~/Desktop/20110909WellF07_Tracking.csv")
head(orig)
pc9_3um_erlotinib$lifetime <- orig$Lifetime..h.
head(pc9_3um_erlotinib)
pc9_3um_erlotinib$observed <- orig$Lifetime..h.
pc9_3um_erlotinib
divisions <- subset(pc9_3um_erlotinib, end.of.movie=='N' & died=='N')$observed
hist(division)
hist(divisions)
hist(divisions)
intermitotic.time <- subset(pc9_3um_erlotinib, end.of.movie=='N' & died=='N')$observed
hist(intermitotic.time)
library(emg)
head(pc9_3um_erlotinib)
pc9_3um_erlotinib$lifetime <- NULL
head(pc9_3um_erlotinib)
setwd("~/projects/garbetsp/emg/data")
save(pc9_3um_erlotinib, file="pc9_3um_erlotinib.rda")
